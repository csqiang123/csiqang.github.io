## java多线程

### 1，线程，进程的区别

​	进程是指在操作系统中正在运行的一个应用程序，

​	线程是指进程内独立执行某个任务的一个单元。 

### 2，多线程的概念

##### 1，为什么要使用多线程？

​		用多线程只有一个目的，那就是更好的利用cpu的资源 。（在“多角色”的程序代码中，最起码每一个角色都要给他一个线程，否则这个连实际的场景都无法模拟，那么也没有办法去使用单线程来实现）  举个栗子：”生产者，消费者模型“。

##### 2，很多人都对其中的一些概念不够明确，如同步、并发等等

​		一，多线程：指的是这个程序（一个进程）运行时产生了不止一个线程

​		二，并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。			   （举个栗子：多辆汽车在多个跑道上并排行驶）

​		三，并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时（举个栗子 ：多辆汽车在同一跑道上竞速行驶）

### 3，多线程的生命周期（线程状态）

##### 1，新建状态（New）

​	新创建了一个线程对象。 

##### 2，就绪状态（Runnable）

​	线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。

##### 3，运行状态（Running）

​	就绪状态的线程获取了CPU，执行程序代码。

##### 4，阻塞状态（Blocked）

​	阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。

​		阻塞的情况分三种：

​			（一），等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。 

​			（二），同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。

​			（三）、其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。

##### 5，死亡状态（Dead）

​	线程执行完了或者因异常退出了run()方法，该线程结束生命周期。 

##### （画图说明）