# Static 和final

## 1.static

​	static是静态修饰符，一般修饰成员。被static修饰的成员属于类，不属于单个这个类的某个对象。

​	static修饰的成员被多个对象共享。

​       static修饰的成员属于类，但是会影响每一个对象。

​       被static修饰的成员又叫类成员，不叫对象的成员。

​	****被static修饰的成员可以并且建议通过类名直接访问。****

 

## 2.final

final修饰的类无法被继承。

final修饰的方法无法被重写。

final修饰的变量无法被再次赋值。且被final修饰的局部变量即为常量

final修饰的引用类型，不能再指向别的东西，但是可以改变其中的内容。 







# 内部类

内部类分为成员内部类与局部内部类。 

内部类可以直接访问外部类的所有成员。

定义时是一个正常定义类的过程，同样包含各种修饰符、继承与实现关系等。 

外部类编译后会出现两个class文件。 

## 1.成员内部类

定义在成员位置的内部类

定义格式

public class Outer{

​       class Inner{

​              //其他代码

​       }

}

访问格式：

​       **Outer.Inner  x = new Outer().new Inner();**

## 2.局部内部类

定义在局部位置的内部类,在一个方法内定义

注意:不能有访问控制修饰符(默认不写的),但可以用abstract或者final修饰,两者不共存

定义格式

public class Outer{

​       public void method{

​              class Inner{

​              }

​       }

}

访问格式：

​       **只能在外部类的方法中创建对象并访问。**



## 3.匿名内部类

匿名内部类是局部内部类的一种。

过程：

临时定义一个类型的子类

定义后即刻创建刚刚定义的这个类的对象

目的：

​	****匿名内部类是创建某个类型子类对象的快捷方式。****

​	****我们为了临时定义一个类的子类，并创建这个子类的对象而使用匿名内部类。****

格式:

​	****将定义子类与创建子类对象两个步骤由一个格式一次完成。****

​	****虽然是两个步骤，但是两个步骤是连在一起的、即时的。****

​	****匿名内部类如果不定义变量引用，则也是匿名对象****。格式如下：

​       **new 父类(){**

​              //重写需要重写的方法

​       **};**



例如：

​              已经存在的父类：

public abstract class Person{

​                     public abstract void eat();

}

定义并创建该父类的子类对象，并用多态的方式赋值给父类引用变量

Person  p = new Person(){

​                     public void eat() {

​                            System.out.println(“我吃了”);

}

};